# GoPCA Development Guide

## Project Overview

GoPCA is **the definitive Principal Component Analysis (PCA) application** - a focused, professional-grade tool that excels at one thing: PCA analysis. This is not a general-purpose machine learning platform. Our mission is to create the most user-friendly, robust, and feature-complete PCA application available.

**Core Components:**
- **CLI Tool** (`cmd/gopca-cli/`): Fast, scriptable PCA for power users and automation
- **Desktop GUI** (`cmd/gopca-desktop/`): Intuitive Wails-based interface for interactive data exploration
- **Unified Engine** (`internal/core/`): Single, bulletproof PCA implementation serving both interfaces

## Quick Start for New Developers

1. **Setup Development Environment**
   ```bash
   # Install Go 1.21+ and Node.js 18+
   go version  # Should be >= 1.21
   node --version  # Should be >= 18
   
   # Clone and setup
   git clone https://github.com/bitjungle/gopca.git
   cd gopca
   make deps  # Download Go dependencies
   make gui-deps  # Install GUI dependencies
   ```

2. **Install Pre-commit Hooks (REQUIRED)**
   ```bash
   make install-hooks
   ```
   This installs Git hooks that automatically check your code before each commit.

3. **Verify Your Setup**
   ```bash
   ./scripts/check-dev-setup.sh
   ```
   This script checks that your development environment is properly configured.

4. **Build and Run**
   ```bash
   make build  # Build CLI
   make gui-dev  # Run GUI in development mode
   ```

## Code Quality Principles

**DRY (Don't Repeat Yourself)**
- Abstract common PCA operations into reusable functions
- Share preprocessing logic between CLI and GUI
- Centralize matrix operations and validation logic

**KISS (Keep It Simple, Stupid)**
- Favor readable algorithms over micro-optimizations
- Use standard library solutions before external dependencies
- Choose proven approaches over experimental techniques

**Separation of Concerns (SoC)**
- Core PCA engine knows nothing about UI
- CLI and GUI are thin layers over the core engine
- Preprocessing, computation, and visualization are distinct modules

**Readability over Cleverness**
- Variable names must clearly indicate their mathematical meaning (`scores`, `loadings`, `explainedVariance`)
- Functions should have single, obvious purposes
- Complex algorithms require clear comments explaining the mathematical concepts

## Critical Development Rules

### 1. **Automated Pre-commit Checks**
The pre-commit hooks (installed via `make install-hooks`) automatically run:
- `go fmt` - Code formatting
- `go vet` - Static analysis
- `go test` - All tests must pass
- `go mod tidy` - Dependencies must be tidy

If any check fails, the commit will be blocked. To bypass temporarily (NOT recommended):
```bash
git commit --no-verify
```

For manual checking:
```bash
make fmt    # Format code
make test   # Run all tests
make lint   # Run golangci-lint (if installed)

# For GUI changes, also run:
cd cmd/gopca-desktop/frontend && npm run build
```

### 2. **Follow Existing Patterns**
- Study neighboring code before implementing new features
- Use existing utilities and patterns - don't reinvent
- When in doubt, grep the codebase for similar implementations

### 3. **Mathematical Correctness First**
- Every algorithm must be mathematically correct
- Include references to papers/books in comments
- Validate against known test cases (R, MATLAB)

## Project Structure

```
gopca/
├── cmd/                      # Application entry points
│   ├── gopca-cli/           # CLI application
│   │   └── main.go          # CLI entry point
│   └── gopca-desktop/       # Desktop GUI (Wails)
│       ├── main.go          # GUI backend entry
│       └── frontend/        # React frontend
├── internal/                # Private packages
│   ├── core/               # PCA algorithms
│   │   ├── pca.go         # Main PCA implementation
│   │   ├── svd.go         # SVD algorithm
│   │   ├── nipals.go      # NIPALS algorithm
│   │   └── kernel.go      # Kernel PCA
│   ├── io/                # Data I/O operations
│   │   └── csv.go         # CSV parsing
│   ├── cli/               # CLI-specific logic
│   ├── datasets/          # Embedded test datasets for testing
│   └── utils/             # Utility functions
├── pkg/                   # Public packages
│   └── types/             # Shared types/interfaces
│       ├── config.go      # PCA configuration
│       ├── matrix.go      # Matrix operations
│       └── result.go      # Result structures
├── scripts/               # CI/CD scripts
└── Makefile              # Build automation
```

## Code Standards

### Naming Conventions
```go
// Mathematical objects use standard notation
X := data.Matrix()          // Data matrix
U, S, V := SVD(X)          // SVD components

// Functions describe operations
func CenterMatrix(m Matrix) Matrix
func ComputeLoadings(scores Matrix) Matrix

// Types are clear and scoped
type PCAConfig struct { ... }
type PCAResult struct { ... }

// Constants for parameters
const MAX_ITERATIONS = 1000
const CONVERGENCE_TOLERANCE = 1e-10
```

### Error Handling
```go
// Always wrap errors with context
if err := validateMatrix(data); err != nil {
    return nil, fmt.Errorf("PCA fit failed: %w", err)
}

// Mathematical errors are specific
if rank < minComponents {
    return nil, fmt.Errorf("insufficient matrix rank %d for %d components", rank, minComponents)
}
```

### Common Go Pitfalls
```go
// WRONG: Value semantics - data won't accumulate
groupData := make(map[string]struct{x, y []float64})
for _, item := range items {
    data := groupData[key]  // Makes a copy!
    data.x = append(data.x, value)  // Appends to copy
    groupData[key] = data  // Have to write back
}

// CORRECT: Pointer semantics - data accumulates properly
groupData := make(map[string]*struct{x, y []float64})
for _, item := range items {
    if groupData[key] == nil {
        groupData[key] = &struct{x, y []float64}{}
    }
    groupData[key].x = append(groupData[key].x, value)  // Direct append
}
```

### Testing Requirements
```go
// Table-driven tests for all core functions
func TestPCA_Fit(t *testing.T) {
    tests := []struct {
        name     string
        data     Matrix
        config   PCAConfig
        wantErr  bool
        validate func(*testing.T, *PCAResult)
    }{
        // Test cases...
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

## Core Interfaces

```go
// Main PCA engine interface (pkg/types/engine.go)
type PCAEngine interface {
    Fit(data Matrix, config PCAConfig) (*PCAResult, error)
    Transform(data Matrix) (Matrix, error)
    FitTransform(data Matrix, config PCAConfig) (*PCAResult, error)
}

// Configuration structure (pkg/types/config.go)
type PCAConfig struct {
    Components      int         // Number of components
    MeanCenter      bool        // Center data
    StandardScale   bool        // Scale to unit variance
    RobustScale     bool        // Robust scaling
    SNV             bool        // Standard Normal Variate
    VectorNorm      bool        // Vector normalization
    Method          string      // "auto", "svd", "nipals", "kernel"
    MissingStrategy string      // "drop", "mean", "iterative"
    // ... additional fields
}
```

## Git Workflow

### Pre-commit Hooks
Our pre-commit hooks ensure code quality by automatically running checks before each commit:

**What the hooks check:**
- Code formatting (`go fmt`)
- Static analysis (`go vet`)
- All tests pass with race detection
- `go.mod` is tidy (when modified)
- Warns about `fmt.Println` in non-test files
- Warns about new TODO/FIXME comments

**Hook Management:**
```bash
make install-hooks     # Install hooks (do this once)
git commit            # Hooks run automatically
git commit --no-verify # Skip hooks (emergency only!)
rm .git/hooks/pre-commit # Uninstall hooks
```

### Branch Naming
```bash
# Feature branches
git checkout -b 42-add-biplot-export

# Bug fixes
git checkout -b 55-fix-memory-leak

# Documentation
git checkout -b docs-update-api-reference
```

### Commit Messages
```bash
# Format: type: description
git commit -m "feat: add biplot export functionality"
git commit -m "fix: correct eigenvalue calculation for sparse matrices"
git commit -m "docs: update API examples for v2.0"
git commit -m "test: add edge cases for missing data handling"
```

### Pull Request Process
1. Create feature branch from `main`
2. Implement feature with tests
3. Commit changes (pre-commit hooks run automatically)
4. Push branch and create PR
5. Reference issue in PR description
6. Ensure CI passes before merge

### Handling Binary Files and Test Artifacts
- Be cautious about committing binary files (images, PDFs, etc.) unless they're essential documentation
- Test artifacts (comparison plots, output files) should generally not be committed
- If binary files are needed for issue documentation, consider:
  - Mentioning them in the PR description instead of committing
  - Adding them to .gitignore if they're generated frequently
  - Using git LFS for large binary files that must be tracked

## Testing Guidelines

### Test Coverage Requirements
- Core PCA engine: >85% coverage
- Overall project: >70% coverage
- All new features must include tests

### Test Types
```bash
# Unit tests
make test

# Verbose tests with coverage
make test-verbose

# Benchmark tests
go test -bench=. ./internal/core/...

# CI tests (excludes GUI)
make ci-test
```

### Mathematical Validation
Always validate against reference implementations:
```go
// Example: Compare with R results
expectedVariance := []float64{2.9108, 0.9140, 0.1469, 0.0208}
assertFloatSlicesEqual(t, result.ExplainedVariance, expectedVariance, 1e-4)
```

### Writing Robust Numerical Tests
When testing numerical algorithms, especially those involving matrix operations:

1. **Use well-conditioned test data**: Avoid points that are too close together or create singular/near-singular matrices
2. **Test across platforms**: What works on macOS might fail on Linux due to floating-point differences
3. **Example of robust test data for covariance calculations**:
   ```go
   // Good: Well-separated points forming a square
   points := []float64{
       0.0, 0.0,
       1.0, 0.0,
       0.0, 1.0,
       1.0, 1.0,
   }
   
   // Bad: Points too close together (can cause numerical issues)
   points := []float64{
       1.0, 1.1,
       1.2, 0.9,
       0.8, 1.3,
       1.1, 1.0,
   }
   ```

## Common Development Tasks

### Adding a New Algorithm
1. Create algorithm file in `internal/core/`
2. Implement the algorithm with clear comments
3. Add comprehensive tests
4. Update PCAEngine to support new method
5. Add example in documentation

### Adding a New Preprocessing Method
1. Add method to `internal/core/preprocessing.go`
2. Add configuration option to `PCAConfig`
3. Implement with reversible transformations
4. Add tests for edge cases
5. Update CLI and GUI to expose option

### Debugging Performance Issues
```bash
# Run benchmarks
go test -bench=. -benchmem ./internal/core/

# Profile CPU usage
go test -cpuprofile=cpu.prof -bench=.
go tool pprof cpu.prof

# Check memory allocations
go build -gcflags="-m" ./...
```

## GUI Development

### Frontend Setup
```bash
cd cmd/gopca-desktop/frontend
npm install  # Install dependencies
npm run dev  # Development server
npm run build  # Production build
```

### Frontend Stack
- React 18 with TypeScript
- Recharts for visualizations
- TailwindCSS for styling
- Vite for building

### Help System
The GUI includes a comprehensive contextual help system that provides users with immediate assistance:

**Components:**
- **Help Content** (`src/help/help-content.json`): Centralized JSON file containing all help messages
- **HelpContext** (`src/contexts/HelpContext.tsx`): React context for managing help state
- **HelpDisplay** (`src/components/HelpDisplay.tsx`): Component that displays help in the header
- **HelpWrapper** (`src/components/HelpWrapper.tsx`): Wrapper component to add help to any UI element

**Usage:**
```tsx
// Wrap any component to add contextual help on hover
<HelpWrapper helpKey="num-components">
  <input type="number" />
</HelpWrapper>
```

**Adding New Help Content:**
1. Add entry to `help-content.json` with unique key, title, and text
2. Wrap UI element with `<HelpWrapper helpKey="your-key">`
3. Help automatically displays in header when user hovers over element

**Documentation Generation:**
Run `node scripts/generate-help-docs.js` to generate:
- Markdown documentation
- CLI help text
- JSON export for other tools

### Backend-Frontend Communication
- Wails runtime for API calls
- JSON data exchange
- Structured error responses

### Creating Consistent Visualization Plots

When adding a new visualization plot to the GUI, follow these guidelines to ensure maximum consistency with existing plots:

#### 1. **Required Imports and Structure**
```tsx
import React, { useRef, useState, useCallback } from 'react';
import { PCAResult } from '../../types';
import { ExportButton } from '../ExportButton';
import { PlotControls } from '../PlotControls';
import { useChartTheme } from '../../hooks/useChartTheme';
// Additional imports for your specific chart type
```

#### 2. **Component Setup**
Every plot component should include:
```tsx
const YourPlot: React.FC<YourPlotProps> = ({ pcaResult, ...otherProps }) => {
  // Essential refs and state
  const chartRef = useRef<HTMLDivElement>(null);
  const fullscreenRef = useRef<HTMLDivElement>(null);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const chartTheme = useChartTheme();
  
  // Fullscreen handler (standard implementation)
  const handleToggleFullscreen = useCallback(() => {
    if (!fullscreenRef.current) return;
    
    if (!isFullscreen) {
      if (fullscreenRef.current.requestFullscreen) {
        fullscreenRef.current.requestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
    
    setIsFullscreen(!isFullscreen);
  }, [isFullscreen]);

  const handleResetView = useCallback(() => {
    // Implement zoom reset if applicable, otherwise leave empty
  }, []);
```

#### 3. **Layout Structure**
Use this consistent layout pattern:
```tsx
return (
  <div ref={fullscreenRef} className={`w-full h-full ${isFullscreen ? 'fixed inset-0 z-50 bg-white dark:bg-gray-900 p-4' : ''}`}>
    <div className="w-full h-full" ref={chartRef}>
      {/* Header with title and controls */}
      <div className="flex items-center justify-between mb-4">
        <h4 className="text-md font-medium text-gray-700 dark:text-gray-300">
          Plot Title: Component Details
        </h4>
        <div className="flex items-center gap-2">
          <PlotControls 
            onResetView={handleResetView}
            onToggleFullscreen={handleToggleFullscreen}
            isFullscreen={isFullscreen}
            // Add zoom handlers if applicable:
            // onZoomIn={handleZoomIn}
            // onZoomOut={handleZoomOut}
          />
          <ExportButton 
            chartRef={chartRef} 
            fileName="descriptive-filename"
          />
        </div>
      </div>
      
      {/* Chart content */}
      <div style={{ height: isFullscreen ? 'calc(100vh - 80px)' : 'calc(100% - 40px)' }}>
        {/* Your chart implementation */}
      </div>
    </div>
  </div>
);
```

#### 4. **Control Button Ordering**
Always maintain this button order (left to right):
1. Any plot-specific controls (selectors, toggles)
2. PlotControls (zoom buttons if applicable, reset, fullscreen)
3. ExportButton (always rightmost)

**Important spacing rules:**
- Use `gap-2` (8px) between PlotControls and ExportButton
- Use `gap-4` (16px) between different control groups
- Wrap PlotControls and ExportButton in their own div with `gap-2`

#### 5. **Theme Integration**
Always use the chart theme for consistent styling:
```tsx
const chartTheme = useChartTheme();

// Use theme colors in your charts:
<CartesianGrid stroke={chartTheme.gridColor} />
<XAxis stroke={chartTheme.axisColor} />
<text fill={chartTheme.textColor}>Label</text>
```

#### 6. **Error States**
Handle missing data consistently:
```tsx
if (!data || data.length === 0) {
  return (
    <div className="w-full h-full flex items-center justify-center text-gray-400">
      <p>Descriptive message about what's missing</p>
    </div>
  );
}
```

#### 7. **Zoom/Pan Support**
If your plot benefits from zoom/pan functionality:
1. Import and use the `useZoomPan` hook
2. Add the zoom controls to PlotControls
3. Apply zoom domains to your chart axes
4. Handle mouse events for panning

#### 8. **Export Functionality**
- Always provide meaningful filenames that include relevant details
- Example: `scores-plot-PC1-vs-PC2`, `loadings-plot-PC1`

#### 9. **Responsive Design**
- Use `ResponsiveContainer` from Recharts for chart responsiveness
- Adjust margins and padding based on content
- Ensure labels don't overlap at different sizes

#### 10. **TypeScript Types**
Define clear prop interfaces:
```tsx
interface YourPlotProps {
  pcaResult: PCAResult;
  selectedComponent?: number;  // 0-based index
  // Other specific props with documentation
}
```

## Performance Standards

### Benchmarks
- GUI responsive during computation
- Memory efficient for large datasets

### Optimization Guidelines
1. Profile before optimizing
2. Use gonum for matrix operations
3. Minimize allocations in hot paths
4. Consider parallel processing for large datasets

## Debugging and Troubleshooting

### Common Issues
1. **Import cycles**: Keep dependencies acyclic
2. **Memory leaks**: Use pprof to identify
3. **Numerical instability**: Check condition numbers
4. **GUI not updating**: Check Wails event emission
5. **Platform-specific test failures**: Use well-conditioned test data to avoid floating-point precision differences across platforms

### Debug Commands
```bash
# Run with debug logging
GOPCA_DEBUG=1 ./bin/gopca-cli --input data.csv

# Test specific package
go test -v ./internal/core/

# Check for race conditions
go test -race ./...

# Run specific test with verbose output
go test -v -run TestName ./package/

# Test with race detection (important for CI parity)
go test -race -timeout 10m ./...
```

### Debugging CI Failures
When tests pass locally but fail in CI:

1. **Check for platform differences**: CI might use different OS/architecture
2. **Look for race conditions**: Add `-race` flag to match CI behavior
3. **Verify test data quality**: Numerical tests may behave differently across platforms
4. **Add temporary debug logging**: Use `t.Logf()` to understand what's happening
5. **Check CI environment**: Look for cache issues or environment differences
6. **Always create a new branch for fixes**: Never debug directly on main

### Debugging Mathematical/Numerical Issues
When debugging mathematical algorithms or numerical computations:
1. **Compare with reference implementations**: Use plots, test data, or reference outputs (e.g., Python, R, MATLAB)
2. **Check preprocessing consistency**: Ensure data transformations are applied consistently throughout the pipeline
3. **Verify space consistency**: Ensure all calculations operate in the same mathematical space (e.g., centered vs. uncentered)
4. **Test edge cases**: Include tests for different preprocessing combinations and data characteristics
5. **Use visual debugging**: When available, use plots to understand discrepancies

## Release Process

### Pre-release Checklist
- [ ] All tests passing
- [ ] Documentation updated
- [ ] Changelog prepared
- [ ] Performance benchmarks run
- [ ] Cross-platform builds tested

### Build Commands
```bash
# Build for all platforms
make build-all

# Build specific platform
make build-darwin-arm64
make build-linux-amd64
make build-windows-amd64
```

## External Dependencies

### Core Dependencies
- `gonum.org/v1/gonum`: Numerical computing
- `github.com/wailsapp/wails/v2`: Desktop GUI framework
- Standard library preferred for everything else

### Adding New Dependencies
1. Justify the need - can stdlib do it?
2. Check license compatibility
3. Assess maintenance status
4. Add with minimal version constraints
5. Document the purpose

## Code Review Checklist

Before submitting PR:
- [ ] Tests pass locally (`make test`)
- [ ] Code formatted (`make fmt`)
- [ ] Linter passes (`make lint`)
- [ ] Documentation updated
- [ ] Mathematical correctness verified
- [ ] Error handling comprehensive
- [ ] No hardcoded values
- [ ] Follows existing patterns

## Getting Help

### MCP Development Tools
* Always check with **context7** for the latest documentation for protocols, standards, tools, modules, packages and frameworks.
* Use the **puppeteer** to test and verify UI components through automated browser interaction.
* When structured, progressive thinking through defined stages is needed, use **sequential-thinking**.

### Resources
- Original design: `docs_tmp/ENGINEER_GUIDE.md`
- Mathematical reference: Jolliffe's "Principal Component Analysis"
- Gonum docs: https://gonum.org/v1/gonum
- Wails docs: https://wails.io/

### Project Conventions
- Issues: Use GitHub issues for bugs/features
- Discussions: Use PR comments for implementation details
- Code style: Follow existing patterns in codebase

## Remember

1. **Quality over speed**: Better to be correct than fast
2. **Test everything**: No code without tests
3. **Document why**: Code explains what, comments explain why
4. **Keep it simple**: Prefer clarity over cleverness
5. **PCA focus**: We do one thing exceptionally well

This is a living document. Update it when you discover new patterns or make architectural decisions.